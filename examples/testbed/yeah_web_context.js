/* Generated by Opal 0.6.0 */
(function($opal) {
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $module = $opal.module, $klass = $opal.klass, $hash2 = $opal.hash2;

  $opal.add_stubs(['$include', '$new', '$getContext', '$setup_shaders', '$attr_reader', '$[]', '$width', '$height', '$width=', '$height=', '$viewport', '$background', '$each', '$render', '$visual', '$position', '$things', '$rgb', '$clearColor', '$clear', '$COLOR_BUFFER_BIT', '$uniform3f', '$getUniformLocation', '$uniform2f', '$resolution', '$+', '$createBuffer', '$bindBuffer', '$ARRAY_BUFFER', '$bufferData', '$STATIC_DRAW', '$vertexAttribPointer', '$FLOAT', '$drawArrays', '$TRIANGLE_STRIP', '$private', '$createProgram', '$createShader', '$VERTEX_SHADER', '$shaderSource', '$compileShader', '$attachShader', '$FRAGMENT_SHADER', '$linkProgram', '$getProgramParameter', '$LINK_STATUS', '$!', '$getProgramInfoLog', '$puts', '$useProgram', '$getAttribLocation', '$enableVertexAttribArray']);
  return (function($base) {
    var self = $module($base, 'Yeah');

    var def = self._proto, $scope = self._scope;

    (function($base) {
      var self = $module($base, 'Web');

      var def = self._proto, $scope = self._scope;

      (function($base, $super) {
        function $Screen(){};
        var self = $Screen = $klass($base, $super, 'Screen', $Screen);

        var def = self._proto, $scope = self._scope, $a;

        def.canvas = def.gl = def.col_loc = def.shader_program = def.pos_loc = nil;
        self.$include((($a = $scope.Opal) == null ? $opal.cm('Opal') : $a));

        $opal.cdecl($scope, 'VERTEX_SHADER', "    attribute vec2 a_position;\n\n    uniform vec2 u_resolution;\n\n    void main(void) {\n      vec2 clipspace = a_position / u_resolution * 2.0 - 1.0;\n\n      gl_Position = vec4(clipspace, 0, 1);\n    }\n");

        $opal.cdecl($scope, 'FRAGMENT_SHADER', "    precision mediump float;\n\n    uniform vec3 u_color;\n\n    void main(void) {\n      gl_FragColor = vec4(u_color, 1.0);\n    }\n");

        def.$initialize = function() {
          var $a, $b, self = this;

          self.canvas = (($a = ((($b = $scope.Native) == null ? $opal.cm('Native') : $b))._scope).Object == null ? $a.cm('Object') : $a.Object).$new(document.getElementsByTagName('canvas')[0]);
          self.gl = self.canvas.$getContext("webgl");
          return self.$setup_shaders();
        };

        self.$attr_reader("canvas");

        def.$resolution = function() {
          var $a, self = this;

          return (($a = $scope.V) == null ? $opal.cm('V') : $a)['$[]'](self.canvas.$width(), self.canvas.$height());
        };

        def['$resolution='] = function(value) {
          var $a, self = this;

          value = (($a = $scope.V) == null ? $opal.cm('V') : $a)['$[]'](value);
          self.canvas['$width='](value['$[]'](0));
          return self.canvas['$height='](value['$[]'](1));
        };

        def.$render = function(space) {
          var $a, $b, TMP_1, self = this;

          self.gl.$viewport(0, 0, self.canvas.$width(), self.canvas.$height());
          self.$background(space.$background());
          return ($a = ($b = space.$things()).$each, $a._p = (TMP_1 = function(thing){var self = TMP_1._s || this;
if (thing == null) thing = nil;
          return thing.$visual().$render(self, thing.$position())}, TMP_1._s = self, TMP_1), $a).call($b);
        };

        def.$background = function(color) {
          var $a, $b, self = this, rgb = nil;

          color = $slice.call(arguments, 0);
          rgb = ($a = (($b = $scope.Color) == null ? $opal.cm('Color') : $b))['$[]'].apply($a, [].concat(color)).$rgb();
          ($b = self.gl).$clearColor.apply($b, [].concat(rgb).concat(1));
          return self.gl.$clear(self.gl.$COLOR_BUFFER_BIT());
        };

        def.$color = function(color) {
          var $a, self = this;

          return ($a = self.gl).$uniform3f.apply($a, [self.col_loc].concat(color.$rgb()));
        };

        def.$rectangle = function(position, size) {
          var $a, $b, self = this, res = nil, rect = nil, vertices = nil, pos_buffer = nil, gl_vertices = nil;

          res = self.gl.$getUniformLocation(self.shader_program, "u_resolution");
          self.gl.$uniform2f(res, self.$resolution()['$[]'](0), self.$resolution()['$[]'](1));
          rect = $hash2(["left", "bottom", "width", "height"], {"left": position['$[]'](0), "bottom": position['$[]'](1), "width": size['$[]'](0), "height": size['$[]'](1)});
          vertices = [rect['$[]']("left"), rect['$[]']("bottom"), rect['$[]']("left"), rect['$[]']("bottom")['$+'](rect['$[]']("height")), rect['$[]']("left")['$+'](rect['$[]']("width")), rect['$[]']("bottom"), rect['$[]']("left")['$+'](rect['$[]']("width")), rect['$[]']("bottom")['$+'](rect['$[]']("height"))];
          pos_buffer = self.gl.$createBuffer();
          self.gl.$bindBuffer(self.gl.$ARRAY_BUFFER(), pos_buffer);
          gl_vertices = (($a = ((($b = $scope.Native) == null ? $opal.cm('Native') : $b))._scope).Object == null ? $a.cm('Object') : $a.Object).$new(new Float32Array(vertices));
          self.gl.$bufferData(self.gl.$ARRAY_BUFFER(), gl_vertices, self.gl.$STATIC_DRAW());
          self.gl.$vertexAttribPointer(self.pos_loc, 2, self.gl.$FLOAT(), false, 0, 0);
          return self.gl.$drawArrays(self.gl.$TRIANGLE_STRIP(), 0, 4);
        };

        self.$private();

        return (def.$setup_shaders = function() {
          var $a, self = this, vertex_shader = nil, fragment_shader = nil, linked = nil, error = nil;

          self.shader_program = self.gl.$createProgram();
          vertex_shader = self.gl.$createShader(self.gl.$VERTEX_SHADER());
          self.gl.$shaderSource(vertex_shader, (($a = $scope.VERTEX_SHADER) == null ? $opal.cm('VERTEX_SHADER') : $a));
          self.gl.$compileShader(vertex_shader);
          self.gl.$attachShader(self.shader_program, vertex_shader);
          fragment_shader = self.gl.$createShader(self.gl.$FRAGMENT_SHADER());
          self.gl.$shaderSource(fragment_shader, (($a = $scope.FRAGMENT_SHADER) == null ? $opal.cm('FRAGMENT_SHADER') : $a));
          self.gl.$compileShader(fragment_shader);
          self.gl.$attachShader(self.shader_program, fragment_shader);
          self.gl.$linkProgram(self.shader_program);
          linked = self.gl.$getProgramParameter(self.shader_program, self.gl.$LINK_STATUS());
          if ((($a = linked['$!']()) !== nil && (!$a._isBoolean || $a == true))) {
            error = self.gl.$getProgramInfoLog(self.shader_program);
            self.$puts("GL program link error: " + (error));
            return nil;};
          self.gl.$useProgram(self.shader_program);
          self.pos_loc = self.gl.$getAttribLocation(self.shader_program, "a_position");
          self.gl.$enableVertexAttribArray(self.pos_loc);
          return self.col_loc = self.gl.$getUniformLocation(self.shader_program, "u_color");
        }, nil) && 'setup_shaders';
      })(self, null)
      
    })(self)
    
  })(self)
})(Opal);

//# sourceMappingURL=/__opal_source_maps__/yeah/platforms/web/context/screen.js.map
;
/* Generated by Opal 0.6.0 */
(function($opal) {
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $module = $opal.module, $klass = $opal.klass;

  $opal.add_stubs(['$setup_position_listener', '$setup_click_listeners', '$[]', '$private', '$addEventListener', '$getBoundingClientRect', '$canvas', '$width', '$height', '$left', '$top', '$-', '$y=', '$y', '$/', '$*', '$resolution', '$===']);
  return (function($base) {
    var self = $module($base, 'Yeah');

    var def = self._proto, $scope = self._scope;

    (function($base) {
      var self = $module($base, 'Web');

      var def = self._proto, $scope = self._scope;

      (function($base, $super) {
        function $Mouse(){};
        var self = $Mouse = $klass($base, $super, 'Mouse', $Mouse);

        var def = self._proto, $scope = self._scope;

        def.position = def.left_clicking = def.middle_clicking = def.right_clicking = def.screen = nil;
        def.$initialize = function(screen) {
          var self = this;

          self.screen = screen;
          self.$setup_position_listener();
          return self.$setup_click_listeners();
        };

        def.$position = function() {
          var $a, $b, self = this;

          return ((($a = self.position) !== false && $a !== nil) ? $a : self.position = (($b = $scope.V) == null ? $opal.cm('V') : $b)['$[]']());
        };

        def['$left_clicking?'] = function() {
          var $a, self = this;

          return ((($a = self.left_clicking) !== false && $a !== nil) ? $a : false);
        };

        def['$middle_clicking?'] = function() {
          var $a, self = this;

          return ((($a = self.middle_clicking) !== false && $a !== nil) ? $a : false);
        };

        def['$right_clicking?'] = function() {
          var $a, self = this;

          return ((($a = self.right_clicking) !== false && $a !== nil) ? $a : false);
        };

        self.$private();

        def.$setup_position_listener = function() {
          var $a, $b, TMP_1, self = this;

          return ($a = ($b = self.screen.$canvas()).$addEventListener, $a._p = (TMP_1 = function(event){var self = TMP_1._s || this, $a, canvas_bounds = nil, canvas_size = nil, canvas_offset = nil, real_mouse_pos = nil, canvas_mouse_pos = nil;
            if (self.screen == null) self.screen = nil;
if (event == null) event = nil;
          canvas_bounds = self.screen.$canvas().$getBoundingClientRect();
            canvas_size = (($a = $scope.V) == null ? $opal.cm('V') : $a)['$[]'](canvas_bounds.$width(), canvas_bounds.$height());
            canvas_offset = (($a = $scope.V) == null ? $opal.cm('V') : $a)['$[]'](canvas_bounds.$left(), canvas_bounds.$top());
            real_mouse_pos = (($a = $scope.V) == null ? $opal.cm('V') : $a)['$[]'](event.clientX, event.clientY);
            canvas_mouse_pos = real_mouse_pos['$-'](canvas_offset);
            canvas_mouse_pos['$y='](canvas_size.$y()['$-'](canvas_mouse_pos.$y()));
            return self.position = canvas_mouse_pos['$*'](self.screen.$resolution())['$/'](canvas_size);}, TMP_1._s = self, TMP_1), $a).call($b, "mousemove");
        };

        return (def.$setup_click_listeners = function() {
          var $a, $b, TMP_2, $c, TMP_3, self = this;

          ($a = ($b = self.screen.$canvas()).$addEventListener, $a._p = (TMP_2 = function(event){var self = TMP_2._s || this, $case = nil;
if (event == null) event = nil;
          return (function() {$case = event.button;if ((0)['$===']($case)) {return self.left_clicking = true}else if ((1)['$===']($case)) {return self.middle_clicking = true}else if ((2)['$===']($case)) {return self.right_clicking = true}else { return nil }})()}, TMP_2._s = self, TMP_2), $a).call($b, "mousedown");
          return ($a = ($c = self.screen.$canvas()).$addEventListener, $a._p = (TMP_3 = function(event){var self = TMP_3._s || this, $case = nil;
if (event == null) event = nil;
          return (function() {$case = event.button;if ((0)['$===']($case)) {return self.left_clicking = false}else if ((1)['$===']($case)) {return self.middle_clicking = false}else if ((2)['$===']($case)) {return self.right_clicking = false}else { return nil }})()}, TMP_3._s = self, TMP_3), $a).call($c, "mouseup");
        }, nil) && 'setup_click_listeners';
      })(self, null)
      
    })(self)
    
  })(self)
})(Opal);

//# sourceMappingURL=/__opal_source_maps__/yeah/platforms/web/context/mouse.js.map
;
/* Generated by Opal 0.6.0 */
(function($opal) {
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $module = $opal.module, $klass = $opal.klass;

  $opal.add_stubs(['$include', '$new', '$attr_reader', '$requestAnimationFrame', '$on_tick', '$to_proc']);
  return (function($base) {
    var self = $module($base, 'Yeah');

    var def = self._proto, $scope = self._scope;

    (function($base) {
      var self = $module($base, 'Web');

      var def = self._proto, $scope = self._scope;

      (function($base, $super) {
        function $Context(){};
        var self = $Context = $klass($base, $super, 'Context', $Context);

        var def = self._proto, $scope = self._scope, $a, TMP_1;

        def.screen = def.window = nil;
        self.$include((($a = $scope.Opal) == null ? $opal.cm('Opal') : $a));

        def.$initialize = function() {
          var $a, $b, self = this;

          self.window = (($a = ((($b = $scope.Native) == null ? $opal.cm('Native') : $b))._scope).Object == null ? $a.cm('Object') : $a.Object).$new(window);
          self.screen = (($a = $scope.Screen) == null ? $opal.cm('Screen') : $a).$new();
          return self.mouse = (($a = $scope.Mouse) == null ? $opal.cm('Mouse') : $a).$new(self.screen);
        };

        self.$attr_reader("screen");

        self.$attr_reader("mouse");

        return (def.$on_tick = TMP_1 = function() {
          var $a, $b, TMP_2, self = this, $iter = TMP_1._p, block = $iter || nil;

          TMP_1._p = null;
          return ($a = ($b = self.window).$requestAnimationFrame, $a._p = (TMP_2 = function(){var self = TMP_2._s || this, $a, $b;

          if ($opal.$yieldX(block, []) === $breaker) return $breaker.$v;
            return ($a = ($b = self).$on_tick, $a._p = block.$to_proc(), $a).call($b);}, TMP_2._s = self, TMP_2), $a).call($b);
        }, nil) && 'on_tick';
      })(self, null)
      
    })(self)
    
  })(self)
})(Opal);

//# sourceMappingURL=/__opal_source_maps__/yeah/platforms/web/context.js.map
;
